// 
//  Copyright 2022 Sergey Khabarov, sergeykhbr@gmail.com
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
// 

#include "river_cfg.h"

river_cfg::river_cfg(GenObject *parent) :
    FileObject(parent, "river_cfg"),
    _1_(this, ""),
    _2_(this, "2**Number of CPU slots in the clusters. Some of them could be unavailable"),
    _3_(this, ""),
    CFG_LOG2_CPU_MAX(this, "CFG_LOG2_CPU_MAX", new I32D("2")),
    CFG_CPU_MAX(this, "CFG_CPU_MAX", new I32D("POW2(1,CFG_LOG2_CPU_MAX)")),
    _4_(this),
    CFG_VENDOR_ID(this, "CFG_VENDOR_ID", new Logic("32", "", "0x000000F1")),
    CFG_IMPLEMENTATION_ID(this, "CFG_IMPLEMENTATION_ID", new Logic("32", "", "0x20191123")),
    CFG_HW_FPU_ENABLE(this, "CFG_HW_FPU_ENABLE", new BOOL("true")),
    _5_(this),
    RISCV_ARCH(this, "RISCV_ARCH", new I32D("64")),
    _6_(this),
    CFG_CPU_ADDR_BITS(this, "CFG_CPU_ADDR_BITS", new I32D("CFG_BUS_ADDR_WIDTH")),
    CFG_CPU_ID_BITS(this, "CFG_CPU_ID_BITS", new I32D("1")),
    CFG_CPU_USER_BITS(this, "CFG_CPU_USER_BITS", new I32D("1")),
    _7_(this),
    _8_(this, ""),
    _9_(this, "Branch Predictor Branch Target Buffer (BTB) size"),
    _10_(this, ""),
    CFG_BTB_SIZE(this, "CFG_BTB_SIZE", new I32D("8")),
    _11_(this, "Branch predictor depth. It is better when it is equal to the pipeline depth excluding fetcher."),
    _12_(this, "Let it be equal to the decoder's history depth"),
    CFG_BP_DEPTH(this, "CFG_BP_DEPTH", new I32D("5")),
    _13_(this),
    _14_(this, ""),
    _15_(this, "Decoded instructions history buffer size in Decoder"),
    _16_(this, ""),
    CFG_DEC_DEPTH(this, "CFG_DEC_DEPTH", new I32D("SUB(CFG_BP_DEPTH,3)"), "requested, fetching, fetched"),
    _17_(this),
    _18_(this, "Power-on start address can be free changed"),
    CFG_RESET_VECTOR(this, "CFG_RESET_VECTOR", new Logic(&CFG_CPU_ADDR_BITS, "", "0x10000")),
    _19_(this),
    _20_(this, "Valid size 0..16"),
    CFG_PROGBUF_REG_TOTAL(this, "CFG_PROGBUF_REG_TOTAL", new I32D("16")),
    _21_(this, "Must be at least 2 to support RV64I"),
    CFG_DATA_REG_TOTAL(this, "CFG_DATA_REG_TOTAL", new I32D("4")),
    _22_(this, "Total number of dscratch registers"),
    CFG_DSCRATCH_REG_TOTAL(this, "CFG_DSCRATCH_REG_TOTAL", new I32D("2")),
    _23_(this, "Number of elements each 2*CFG_ADDR_WIDTH in stack trace buffer:"),
    CFG_LOG2_STACK_TRACE_ADDR(this, "CFG_LOG2_STACK_TRACE_ADDR", new I32D("5")),
    STACK_TRACE_BUF_SIZE(this, "STACK_TRACE_BUF_SIZE", new I32D("POW2(1,CFG_LOG2_STACK_TRACE_ADDR)")),
    _24_(this),
    _25_(this, ""), 
    _26_(this, "ICacheLru config (16 KB by default)"),
    _27_(this, ""),
    CFG_ILOG2_BYTES_PER_LINE(this, "CFG_ILOG2_BYTES_PER_LINE", new I32D("5"), "[4:0] 32 Bytes = 4x8 B log2(Bytes per line)"),
    CFG_ILOG2_LINES_PER_WAY(this, "CFG_ILOG2_LINES_PER_WAY", new I32D("7")),
    CFG_ILOG2_NWAYS(this, "CFG_ILOG2_NWAYS", new I32D("2")),
    _28_(this),
    _29_(this, "Derivatives I$ constants:"),
    ICACHE_BYTES_PER_LINE(this, "ICACHE_BYTES_PER_LINE", new I32D("POW2(1,CFG_ILOG2_BYTES_PER_LINE)")),
    ICACHE_LINES_PER_WAY(this, "ICACHE_LINES_PER_WAY", new I32D("POW2(1,CFG_ILOG2_LINES_PER_WAY)")),
    ICACHE_WAYS(this, "ICACHE_WAYS", new I32D("POW2(1,CFG_ILOG2_NWAYS)")),
    ICACHE_LINE_BITS(this, "ICACHE_LINE_BITS", new I32D("MUL(8,ICACHE_BYTES_PER_LINE)")),
    _30_(this),
    _31_(this, "Information: To define the CACHE SIZE in Bytes use the following:"),
    ICACHE_SIZE_BYTES(this, "ICACHE_SIZE_BYTES", new I32D("MUL(ICACHE_WAYS,MUL(ICACHE_LINES_PER_WAY,ICACHE_BYTES_PER_LINE))")),
    _32_(this),
    ITAG_FL_TOTAL(this, "ITAG_FL_TOTAL", new I32D("1")),
    _33_(this),
    _34_(this),
    _35_(this, ""),
    _36_(this, "DCacheLru config (16 KB by default)"),
    _37_(this, ""),
    CFG_DLOG2_BYTES_PER_LINE(this, "CFG_DLOG2_BYTES_PER_LINE", new I32D("5"), "[4:0] 32 Bytes = 4x8 B log2(Bytes per line)"),
    CFG_DLOG2_LINES_PER_WAY(this, "CFG_DLOG2_LINES_PER_WAY", new I32D("7"), "7=16KB; 8=32KB; .."),
    CFG_DLOG2_NWAYS(this, "CFG_DLOG2_NWAYS", new I32D("2")),
    _38_(this),
    _39_(this, "Derivatives D$ constants:"),
    DCACHE_BYTES_PER_LINE(this, "DCACHE_BYTES_PER_LINE", new I32D("POW2(1,CFG_DLOG2_BYTES_PER_LINE)")),
    DCACHE_LINES_PER_WAY(this, "DCACHE_LINES_PER_WAY", new I32D("POW2(1,CFG_DLOG2_LINES_PER_WAY)")),
    DCACHE_WAYS(this, "DCACHE_WAYS", new I32D("POW2(1,CFG_DLOG2_NWAYS)")),
    _40_(this),
    DCACHE_LINE_BITS(this, "DCACHE_LINE_BITS", new I32D("MUL(8,DCACHE_BYTES_PER_LINE)")),
    _41_(this),
    _42_(this, "Information: To define the CACHE SIZE in Bytes use the following:"),
    DCACHE_SIZE_BYTES(this, "DCACHE_SIZE_BYTES", new I32D("MUL(DCACHE_WAYS,MUL(DCACHE_LINES_PER_WAY,DCACHE_BYTES_PER_LINE))")),
    _43_(this),
    TAG_FL_VALID(this, "TAG_FL_VALID", new I32D("0"), "always 0"),
    DTAG_FL_DIRTY(this, "DTAG_FL_DIRTY", new I32D("1")),
    DTAG_FL_SHARED(this, "DTAG_FL_SHARED", new I32D("2")),
    DTAG_FL_RESERVED(this, "DTAG_FL_RESERVED", new I32D("3")),
    DTAG_FL_TOTAL(this, "DTAG_FL_TOTAL", new I32D("4")),
    _44_(this),
    _45_(this),
    _46_(this, ""),
    _47_(this, "L1 cache common parameters (suppose I$ and D$ have the same size)"),
    _48_(this, ""),
    L1CACHE_BYTES_PER_LINE(this, "L1CACHE_BYTES_PER_LINE", new I32D("DCACHE_BYTES_PER_LINE")),
    L1CACHE_LINE_BITS(this, "L1CACHE_LINE_BITS", new I32D("MUL(8,DCACHE_BYTES_PER_LINE)")),
    _50_(this),
    SNOOP_REQ_TYPE_READDATA(this, "SNOOP_REQ_TYPE_READDATA", new I32D("0"), "0=check flags; 1=data transfer"),
    SNOOP_REQ_TYPE_READCLEAN(this, "SNOOP_REQ_TYPE_READCLEAN", new I32D("1"), "0=do nothing; 1=read and invalidate line"),
    SNOOP_REQ_TYPE_BITS(this, "SNOOP_REQ_TYPE_BITS", new I32D("2")),
    _57_(this),
    _58_(this),
    _59_(this, ""),
    _60_(this, "L2 cache config (River 16 KB by default, Wasserfall 64 KB)"),
    _61_(this, ""),
    CFG_L2_LOG2_BYTES_PER_LINE(this, "CFG_L2_LOG2_BYTES_PER_LINE", new I32D("5"), "[4:0] 32 Bytes = 4x8 B log2(Bytes per line)"),
    CFG_L2_LOG2_LINES_PER_WAY(this, "CFG_L2_LOG2_LINES_PER_WAY", new I32D("7"), "7=16KB; 8=32KB; 9=64KB, .."),
    CFG_L2_LOG2_NWAYS(this, "CFG_L2_LOG2_NWAYS", new I32D("2")),
    _62_(this),
    _63_(this, "Derivatives D$ constants:"),
    L2CACHE_BYTES_PER_LINE(this, "L2CACHE_BYTES_PER_LINE", new I32D("POW2(1,CFG_L2_LOG2_BYTES_PER_LINE)")),
    L2CACHE_LINES_PER_WAY(this, "L2CACHE_LINES_PER_WAY", new I32D("POW2(1,CFG_L2_LOG2_LINES_PER_WAY)")),
    L2CACHE_WAYS(this, "L2CACHE_WAYS", new I32D("POW2(1,CFG_L2_LOG2_NWAYS)")),
    _64_(this),
    L2CACHE_LINE_BITS(this, "L2CACHE_LINE_BITS", new I32D("MUL(8,L2CACHE_BYTES_PER_LINE)")),
    L2CACHE_SIZE_BYTES(this, "L2CACHE_SIZE_BYTES", new I32D("MUL(L2CACHE_WAYS,MUL(L2CACHE_LINES_PER_WAY,L2CACHE_BYTES_PER_LINE))")),
    _65_(this),
    L2TAG_FL_DIRTY(this, "L2TAG_FL_DIRTY", new I32D("1")),
    L2TAG_FL_TOTAL(this, "L2TAG_FL_TOTAL", new I32D("2")),
    _66_(this),
    L2_REQ_TYPE_WRITE(this, "L2_REQ_TYPE_WRITE", new I32D("0")),
    L2_REQ_TYPE_CACHED(this, "L2_REQ_TYPE_CACHED", new I32D("1")),
    L2_REQ_TYPE_UNIQUE(this, "L2_REQ_TYPE_UNIQUE", new I32D("2")),
    L2_REQ_TYPE_SNOOP(this, "L2_REQ_TYPE_SNOOP", new I32D("3"), "Use data received through snoop channel (no memory request)"),
    L2_REQ_TYPE_BITS(this, "L2_REQ_TYPE_BITS", new I32D("4")),
    _67_(this),
    _68_(this, "MPU config"),
    CFG_MPU_TBL_WIDTH(this, "CFG_MPU_TBL_WIDTH", new I32D("3"), "[1:0]  log2(MPU_TBL_SIZE)"),
    CFG_MPU_TBL_SIZE(this, "CFG_MPU_TBL_SIZE", new I32D("POW2(1,CFG_MPU_TBL_WIDTH)")),
    _69_(this),
    CFG_MPU_FL_WR(this, "CFG_MPU_FL_WR", new I32D("0")),
    CFG_MPU_FL_RD(this, "CFG_MPU_FL_RD", new I32D("1")),
    CFG_MPU_FL_EXEC(this, "CFG_MPU_FL_EXEC", new I32D("2")),
    CFG_MPU_FL_CACHABLE(this, "CFG_MPU_FL_CACHABLE", new I32D("3")),
    CFG_MPU_FL_ENA(this, "CFG_MPU_FL_ENA", new I32D("4")),
    CFG_MPU_FL_TOTAL(this, "CFG_MPU_FL_TOTAL", new I32D("5")),
    _70_(this),
    _71_(this),
    MEMOP(this),
    _72_(this),
    _73_(this, "Dport request types:"),
    DPortReq_Write(this, "DPortReq_Write", new I32D("0")),
    DPortReq_RegAccess(this, "DPortReq_RegAccess", new I32D("1")),
    DPortReq_MemAccess(this, "DPortReq_MemAccess", new I32D("2")),
    DPortReq_MemVirtual(this, "DPortReq_MemVirtual", new I32D("3")),
    DPortReq_Progexec(this, "DPortReq_Progexec", new I32D("4")),
    DPortReq_Total(this, "DPortReq_Total", new I32D("5")),
    _IsaType0_(this),
    _IsaType1_(this, "Instruction formats specified by ISA specification"),
    EIsaType(this),
    _IsaType2_(this),
    _InstrList0_(this, "Implemented instruction list and its indexes"),
    EInstructionType(this),
    _InstrList1_(this),
    Instr_FPU_Total(this, "Instr_FPU_Total", new I32D("ADD(SUB(Instr_FSUB_D,Instr_FADD_D),1)")),
    _InstrList2_(this),
    _MemoryAccess0_(this, "Depth of the fifo between Executor and MemoryAccess modules."),
    CFG_MEMACCESS_QUEUE_DEPTH(this, "CFG_MEMACCESS_QUEUE_DEPTH", new I32D("2")),
    _79_(this, "Register's tag used to detect reg hazard and it should be higher than available"),
    _80_(this, "slots in the fifo Executor => Memaccess."),
    CFG_REG_TAG_WIDTH(this, "CFG_REG_TAG_WIDTH", new I32D("3")),
    _81_(this),
    _82_(this, "Request type: [0]-read csr; [1]-write csr; [2]-change mode"),
    CsrReq_ReadBit(this, "CsrReq_ReadBit", new I32D("0")),
    CsrReq_WriteBit(this, "CsrReq_WriteBit", new I32D("1")),
    CsrReq_TrapReturnBit(this, "CsrReq_TrapReturnBit", new I32D("2")),
    CsrReq_ExceptionBit(this, "CsrReq_ExceptionBit", new I32D("3"), "return instruction pointer"),
    CsrReq_InterruptBit(this, "CsrReq_InterruptBit", new I32D("4"), "return instruction pointer"),
    CsrReq_BreakpointBit(this, "CsrReq_BreakpointBit", new I32D("5")),
    CsrReq_HaltBit(this, "CsrReq_HaltBit", new I32D("6")),
    CsrReq_ResumeBit(this, "CsrReq_ResumeBit", new I32D("7")),
    CsrReq_WfiBit(this, "CsrReq_WfiBit", new I32D("8"), "wait for interrupt"),
    CsrReq_TotalBits(this, "CsrReq_TotalBits", new I32D("9")),
    _83_(this),
    CsrReq_ReadCmd(this, "CsrReq_ReadCmd", new Logic("CsrReq_TotalBits", "", "POW2(1,CsrReq_ReadBit)")),
    CsrReq_WriteCmd(this, "CsrReq_WriteCmd", new Logic("CsrReq_TotalBits", "", "POW2(1,CsrReq_WriteBit)")),
    CsrReq_TrapReturnCmd(this, "CsrReq_TrapReturnCmd", new Logic("CsrReq_TotalBits", "", "POW2(1,CsrReq_TrapReturnBit)")),
    CsrReq_ExceptionCmd(this, "CsrReq_ExceptionCmd", new Logic("CsrReq_TotalBits", "", "POW2(1,CsrReq_ExceptionBit)")),
    CsrReq_InterruptCmd(this, "CsrReq_InterruptCmd", new Logic("CsrReq_TotalBits", "", "POW2(1,CsrReq_InterruptBit)")),
    CsrReq_BreakpointCmd(this, "CsrReq_BreakpointCmd", new Logic("CsrReq_TotalBits", "", "POW2(1,CsrReq_BreakpointBit)")),
    CsrReq_HaltCmd(this, "CsrReq_HaltCmd", new Logic("CsrReq_TotalBits", "", "POW2(1,CsrReq_HaltBit)")),
    CsrReq_ResumeCmd(this, "CsrReq_ResumeCmd", new Logic("CsrReq_TotalBits", "", "POW2(1,CsrReq_ResumeBit)")),
    CsrReq_WfiCmd(this, "CsrReq_WfiCmd", new Logic("CsrReq_TotalBits", "", "POW2(1,CsrReq_WfiBit)")),
    _84_(this),
    MemopType_Store(this, "MemopType_Store", new I32D("0"), "0=load; 1=store"),
    MemopType_Locked(this, "MemopType_Locked", new I32D("1"), "AMO instructions"),
    MemopType_Reserve(this, "MemopType_Reserve", new I32D("2"), "LS load with reserve"),
    MemopType_Release(this, "MemopType_Release", new I32D("3"), "SC store with release"),
    MemopType_Total(this, "MemopType_Total", new I32D("4")),
    _n_(this)
{
}
